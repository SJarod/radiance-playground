#version 450

#define M_PI 3.1415926535897932384626433832795

layout(binding = 0) uniform sampler2D baseImage;

struct probe
{
	vec2 position;
};

struct cascade_desc
{
    // number of probes p
    int p;
    // number of discrete values per probes q
    int q;

    // interval length
    float dw;
};

vec2 get_direction_from_angle(float w)
{
	return normalize(vec2(cos(w), sin(w)));
}

layout (std140, binding = 1) uniform parameters {
    int maxCascadeCount;
    int maxProbeCount;
    int minDiscreteValueCount;
    float minRadianceintervalLength;
    float lightIntensity;
    int maxRayIterationCount;
} paramsubo;

// cascade desc buffer
layout (std430, binding = 2) readonly buffer CascadeDescUBO {
    cascade_desc[] descs;
} cdubo;

// cascade probes position buffer
layout (std140, binding = 3) readonly buffer CascadeUBO {
    probe[] positions;
} cubo;

// radiance interval storage buffer
layout (std140, binding = 4) buffer RadianceIntervalUBO {
    vec4[] intervals;
} riubo;

// raycasting to detect incoming radiance to a point p (and detect transparency)
// R(p, w)
vec4 raycasting_function(vec2 p, vec2 dir, float len)
{
	float stepSize = len / float(paramsubo.maxRayIterationCount);
	vec2 sampledStep = p;
    
	vec4 incomingRadiance = vec4(0.0);
	for (int i = 0; i < paramsubo.maxRayIterationCount + 1; ++i)
	{
		// incoming radiance (direct lighting)
		// in flatland, the incoming radiance is the color of the render texture
		// in 3D it would be the lighting value of the hit surface
		// the raycasting function may use a quadtree or octree to
		// process through the ray in a scene independent manner
		vec4 directLighting = texture(baseImage, sampledStep);
		// directLighting.a == 1.0 : opaque (raycast hit)
		// directLighting.a == 0.0 : transparent (raycast miss)
        float hit = step(0.5, directLighting.w);
        
		incomingRadiance = directLighting * hit;
        // radiance.a == 1.0 : transparent (transparency value)
        // radiance.a == 0.0 : opaque
        incomingRadiance.a = 1.0 - hit;
        
        sampledStep += dir * stepSize * (1.0 - hit); // only move step if hit failed
	}
    return incomingRadiance;
}

vec4 probe_encode_radiance(inout probe p, in int intervalIndex, in int intervalCount, in float intervalLength, in float intervalOffset)
{
	// 1D direction (angle)
	// in 3D it would be a 2D direction (longitude and latitude)
	float angle = 2.0 * float(M_PI) / float(intervalCount);
	float w = angle / 2.0 + angle * float(intervalIndex);

	vec2 dir = get_direction_from_angle(w);
    
    // radiance interval
    vec4 interval = raycasting_function(p.position + dir * intervalOffset, dir, intervalLength);
    // debug : show blue value for interval index
    //interval.b = float(intervalIndex) / float(intervalCount);
    return interval;
}

// the cascades are managed by the dispatch (work group)
// dimension that manages the number of probes per cascade
#define LOCAL_SIZE_X 128
// dimension that manages the number of intervals per probe
#define LOCAL_SIZE_Y 8
#define LOCAL_SIZE_Z 1
layout (local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y, local_size_z = LOCAL_SIZE_Z) in;

int get_computed_probe_index(int perThreadProbeStrideIndex)
{
    int cascadeIndex = int(gl_WorkGroupID.x);

    cascade_desc desc = cdubo.descs[cascadeIndex];
    cascade_desc previous_desc = cdubo.descs[max(0, cascadeIndex - 1)];

    int cascadeOffset = previous_desc.p * min(cascadeIndex, 1);

    int probeCount = desc.p;
    int intervalCount = desc.q;

    int perThreadProbeStrideMul = probeCount / LOCAL_SIZE_X;
    int perThreadProbeStride = probeCount / min(1, perThreadProbeStrideMul);

    int probeIndex = 0;
    // jump cascades to reach to current cascade
    probeIndex += cascadeOffset;
    // allow a thread to compute more than one probe if local size x is not high enough
    probeIndex += perThreadProbeStride * perThreadProbeStrideIndex;
    // jump intervals to access the first interval of the probe
    probeIndex += int(gl_LocalInvocationID.x) * intervalCount;
    return probeIndex;
}
int get_computed_interval_index(int perThreadProbeStrideIndex, int perThreadIntervalStrideIndex)
{
    int cascadeIndex = int(gl_WorkGroupID.x);
    cascade_desc desc = cdubo.descs[cascadeIndex];
    int intervalCount = desc.q;

    int intervalIndex = 0;
    // get the according probe
    intervalIndex += get_computed_probe_index(perThreadProbeStrideIndex);
    // goto the wanted interval
    intervalIndex += int(gl_LocalInvocationID.y);
    // allow a thread to compute multiple intervals if local size y is not high enough
    intervalIndex += perThreadIntervalStrideIndex * LOCAL_SIZE_Y;
    return intervalIndex;
}

void main() 
{
#if 0
    riubo.intervals[0] = vec4(gl_WorkGroupSize, 0.0);
    riubo.intervals[1] = vec4(gl_NumWorkGroups, 0.0);
    riubo.intervals[2] = vec4(gl_WorkGroupID, 0.0);
    riubo.intervals[3] = vec4(gl_LocalInvocationID, 0.0);
    riubo.intervals[4] = vec4(gl_GlobalInvocationID, 0.0);
    riubo.intervals[5] = vec4(gl_LocalInvocationIndex, 0.0, 0.0, 0.0);
    for (int i = 0; i < gl_NumWorkGroups.x; ++i)
    {
        riubo.intervals[6][i] = (gl_WorkGroupID * gl_WorkGroupSize).x;
        riubo.intervals[7][i] = (gl_WorkGroupID * gl_NumWorkGroups).x;
    }
    riubo.intervals[8][gl_WorkGroupID.x] = gl_WorkGroupID.x;
    return;
#elif 0
    int cascadeIndex = int(gl_WorkGroupID.x);
    cascade_desc desc = cdubo.descs[cascadeIndex];
    int probeCount = desc.p;
    int intervalCount = desc.q;
    int perThreadStride = max(1, probeCount / LOCAL_SIZE_X);
    for (int t = 0; t < perThreadStride; ++t)
    {
        int perThreadIntervalStrid = intervalCount / LOCAL_SIZE_Y;

        for (int tt = 0; tt < perThreadIntervalStrid; ++tt)
        {
            riubo.intervals[get_computed_interval_index(t, tt)] =
                vec4(get_computed_probe_index(t),
                    get_computed_interval_index(t, tt),
                    gl_LocalInvocationID.y * perThreadIntervalStrid,
                    desc.q);
        }
    }
    return;
#else
    if (gl_WorkGroupID.x > paramsubo.maxCascadeCount)
        return;

    // radiance gather
    int cascadeIndex = int(gl_WorkGroupID.x);
    
    vec4 result = vec4(0.0);
        
    cascade_desc desc = cdubo.descs[cascadeIndex];
    int probeCount = desc.p;
    int intervalCount = desc.q;
    int perThreadStride = max(1, probeCount / LOCAL_SIZE_X);

    float intervalLength = desc.dw;

    // iteration per thread
    // number of "per thread" strides in a "cascade stride"
    for (int t = 0; t < perThreadStride; ++t)
    {
        int perThreadIntervalStrid = intervalCount / LOCAL_SIZE_Y;

        for (int tt = 0; tt < perThreadIntervalStrid; ++tt)
        {
	        int intervalIndex = get_computed_interval_index(t, tt);
    
            float intervalOffset = 0.0;
            if (cascadeIndex > 0)
                intervalOffset = pow(2.0, float(cascadeIndex - 1));
            intervalOffset *= float(paramsubo.minRadianceintervalLength);

            probe p;
	        p.position = cubo.positions[get_computed_probe_index(t)].position;
	        vec4 radianceInterval = probe_encode_radiance(p, intervalIndex, intervalCount, intervalLength, intervalOffset);
    
            result = radianceInterval;
    
            riubo.intervals[intervalIndex] = result;
        }
    }
#endif
}